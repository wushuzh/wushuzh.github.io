<!DOCTYPE html>
<html lang="zh-cn">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>python 并发 (3)</title>
<meta name="description" content="个人技术站点">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="all,follow">
<meta name="googlebot" content="index,follow,snippet,archive">
<link rel="stylesheet" href="https://wushuzh.github.io/css/bootstrap.min.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,300,700,400italic">
<link rel="stylesheet" href="https://wushuzh.github.io/css/font-awesome.min.css">
<link rel="stylesheet" href="https://wushuzh.github.io/css/owl.carousel.css">
<link rel="stylesheet" href="https://wushuzh.github.io/css/owl.theme.css">


  <link href="https://wushuzh.github.io/css/style.sea.css" rel="stylesheet" id="theme-stylesheet">

 

  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  


<link href="https://wushuzh.github.io/css/custom.css" rel="stylesheet">
<link rel="shortcut icon" href="https://wushuzh.github.io/img/favicon.png">


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-102509506-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
  <div id="all">
      <div class="container-fluid">
          <div class="row row-offcanvas row-offcanvas-left">
              
              
<div class="col-xs-12 col-sm-12 col-md-12 content-column white-background">
  <div class="small-navbar visible-xs">
  <button type="button" data-toggle="offcanvas" class="btn btn-ghost pull-left"> <i class="fa fa-align-left"> </i>Menu</button>
  <h1 class="small-navbar-heading"><a href="https://wushuzh.github.io/">小强会武术</a></h1>
</div>

  <div class="row">
    <div class="col-lg-10 col-lg-offset-1">
      <div class="content-column-content">
      
      <div class="row">
        <div class="col-sm-4">
          
            <div class="image">
              <img src="https://wushuzh.github.io//img/blog/py-async-socket/seatedsuperman.gif" class="img-responsive" alt="">
            </div>
          
        </div>
        <div class="col-md-6">
            <h2>python 并发 (3)</h2>
                <p>
                  <i class="fa fa-share-square-o fa-fw"></i><a href="/"> 小强会武术</a>
                </p>

                <p>
                <time datetime="2017-09-21 20:19:58 &#43;0800 CST">
                <i class="fa fa-calendar-o fa-fw"></i> 2017-09-21
                </time>
                &middot;
                1407 字
                &middot;
                3 分钟
                </p>

                
                <p>
                  <i class="fa fa-tags fa-fw" aria-hidden="true"></i>
                  <a href="/tags/python">python</a> &nbsp;&nbsp; <a href="/tags/async">async</a>
                </p>
                

        </div>
      </div>
      <br />

         <p>最终版本的 AsyncSocket 及总结
</p>

<h2 id="性能问题">性能问题</h2>

<p>上篇 <a href="https://wushuzh.github.io/blog/2017/09/14/try-io-multiplexing-py/">&ldquo;python 并发 (2)&rdquo;</a> 最后实现的服务端版本已经能同时服务多个客户端，而不借助多线程。</p>

<p>本篇我们继续对其执行 <a href="https://wushuzh.github.io/blog/2017/09/08/intro-to-py-socket/">&ldquo;python 并发 (1)&rdquo;</a> 中的性能测试。</p>

<p>首先是连续请求 fib(30) 的相应时长:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console">tty1 $ python3 aserver.py
Connected  (&#39;127.0.0.1&#39;, 33092)
Connected  (&#39;127.0.0.1&#39;, 33104)
Closed
task done
Closed
task done

tty2 $ python3 perf1.py
0.2326054573059082
0.2293095588684082
0.24428391456604004
0.46734166145324707
0.4711148738861084
0.4698026180267334
0.4607887268066406
0.23572278022766113
0.23203778266906738
0.2307577133178711

tty3 $ python3 perf1.py
0.6155200004577637
0.4710536003112793
0.4698026180267334
0.460796594619751</code></pre></div>

<p>可以看出，我们依然被 GIL 困扰，相应时间随同时服务的 client 数量线性变大。</p>

<p>之后是每秒最大请求数在单个CPU密集请求时的变化:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console">tty2 $ python3 perf2.py
30783 reqs/sec
33957 reqs/sec
8399 reqs/sec
0 reqs/sec
0 reqs/sec
0 reqs/sec
19083 reqs/sec
31683 reqs/sec
33548 reqs/sec

tty3 $ telnet localhost 25000
36
14930352</code></pre></div>

<p>可以看出，当 fib(36) 执行期间，perf2 客户端上的计算被完全阻隔，完全无法为其提供任何服务。这在本系列的第一篇的最后解释了这是因为 GIL 的任务优先级设定的特性决定的。</p>

<h2 id="新的阻塞">新的阻塞</h2>

<p>这里的解决办法和之前一样: 使用线程池。</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">--- a/aserver.py
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/aserver.py
</span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -5,11 +5,14 @@ from socket import *
</span><span style="color:#75715e"></span> from fib import fib
 from collections import deque
 from select import select
<span style="color:#a6e22e">+from concurrent.futures import ThreadPoolExecutor as Pool
</span><span style="color:#a6e22e"></span>
 tasks = deque()
 recv_wait = { }   # Mapping sockets -&gt; tasks (generators)
 send_wait = { }

<span style="color:#a6e22e">+pool = Pool(10)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e"></span> def run():
     while any([tasks, recv_wait, send_wait]):
         while not tasks:
<span style="color:#75715e">@@ -54,7 +57,8 @@ def fib_handler(client):
</span><span style="color:#75715e"></span>         if not req:
             break
         n = int(req)
<span style="color:#f92672">-        result = fib(n)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+        future = pool.submit(fib, n)
</span><span style="color:#a6e22e">+        result = future.result()  # blocking
</span><span style="color:#a6e22e"></span>         resq = str(result).encode(&#39;ascii&#39;) + b&#39;\n&#39;
         yield &#39;send&#39;, client
         client.send(resq)    # blocking
</code></pre></div>

<p>但如果你仅在此处重复测试一下 perf2，观察到的结果是其每秒服务请求仍然会降到0，问题并没有解决。原因是 <code>future.result()</code> 是被新的线程池代码引入的一个阻塞调用。</p>

<p>即如果你使用协程，你就要全部使用。如果你不知道哪些调用是阻塞性的，并作出相应修改，那么最终性能必然会被这些调用阻塞，而无法达到预期结果。</p>

<h2 id="魔法时刻">魔法时刻</h2>

<p>解决方案是为 <code>future</code> 修补<strong>事件循环调度器</strong>。</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1</span><span style="color:#f92672">--- a/aserver.py
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2</span><span style="color:#f92672"></span><span style="color:#a6e22e">+++ b/aserver.py
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3</span><span style="color:#a6e22e"></span><span style="color:#75715e">@@ -10,6 +10,20 @@ from concurrent.futures import ThreadPoolExecutor as Pool
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4</span><span style="color:#75715e"></span> tasks = deque()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5</span> recv_wait = { }   # Mapping sockets -&gt; tasks (generators)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6</span> send_wait = { }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7</span><span style="color:#a6e22e">+future_wait = { }
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8</span><span style="color:#a6e22e">+
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9</span><span style="color:#a6e22e">+future_notify, future_event = socketpair()
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10</span><span style="color:#a6e22e">+
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">11</span><span style="color:#a6e22e">+def future_done(future):
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">12</span><span style="color:#a6e22e">+    tasks.append(future_wait.pop(future))
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">13</span><span style="color:#a6e22e">+    future_notify.send(b&#39;x&#39;)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">14</span><span style="color:#a6e22e">+
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">15</span><span style="color:#a6e22e">+def future_monitor():
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">16</span><span style="color:#a6e22e">+    while True:
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">17</span><span style="color:#a6e22e">+        yield &#39;recv&#39;, future_event
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">18</span><span style="color:#a6e22e">+        future_event.recv(100)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">19</span><span style="color:#a6e22e">+
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">20</span><span style="color:#a6e22e">+tasks.append(future_monitor())
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">21</span><span style="color:#a6e22e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">22</span> pool = Pool(10)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">23</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">24</span><span style="color:#75715e">@@ -32,6 +46,10 @@ def run():
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">25</span><span style="color:#75715e"></span>                 recv_wait[what] = task
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">26</span>             elif why == &#39;send&#39;:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">27</span>                 send_wait[what] = task
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">28</span><span style="color:#a6e22e">+            elif why == &#39;future&#39;:
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">29</span><span style="color:#a6e22e">+                future_wait[what] = task
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">30</span><span style="color:#a6e22e">+                what.add_done_callback(future_done)
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">31</span><span style="color:#a6e22e">+
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">32</span><span style="color:#a6e22e"></span>             else:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">33</span>                 raise RuntimeError(&#34;ARG!&#34;)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">34</span>         except StopIteration:
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">35</span><span style="color:#75715e">@@ -58,6 +76,7 @@ def fib_handler(client):
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">36</span><span style="color:#75715e"></span>             break
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">37</span>         n = int(req)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">38</span>         future = pool.submit(fib, n)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">39</span><span style="color:#a6e22e">+        yield &#39;future&#39;, future
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">40</span><span style="color:#a6e22e"></span>         result = future.result()  # blocking
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">41</span>         resq = str(result).encode(&#39;ascii&#39;) + b&#39;\n&#39;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">42</span>         yield &#39;send&#39;, client
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">43</span></code></pre></div>

<p>第 39 行: 依然是在阻塞调用前加入 yield ，目的是提示外层程序(第 28、29 行)——即将发生的阻塞是用于等待 future 的结果。继而向 future 注册<code>回调函数 future_done</code>。目的是当 future 计算完成，就将其从 <code>等待区 future_wait</code> 清出，重新放回 tasks 。</p>

<p>第 9 行创建了一个 Unix 域 Socket 名为 socketpair 两端分别为 (<code>future_notify</code>、<code>future_event</code>):</p>

<ul>
<li>第 13 行通过 <code>future_notify</code> 向 socket 发送一个字符 x ;</li>
<li>第 15 ～ 20 行<code>监控函数 future_monitor</code>不断轮循查看 socket 另一端<code>future_event</code>是否接受到字符 x ——此任务也在程序初始时被加入到 tasks 中。</li>
</ul>

<blockquote>
<p>一个有趣的现象是如果使用 ProcessPoolExecutor 而非 ThreadPoolExecutor，我得到了一个诡异的现象</p>
</blockquote>

<p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-console" data-lang="console">tty2 $python3 perf2.py
746 reqs/sec
769 reqs/sec
728 reqs/sec
1492 reqs/sec
1689 reqs/sec
1675 reqs/sec
1683 reqs/sec
1674 reqs/sec
1149 reqs/sec
737 reqs/sec
795 reqs/sec
744 reqs/sec

tty3 $ telnet localhost 25000
36
14930352</code></pre></div></p>

<h2 id="完整示例">完整示例</h2>

<p>最后我们通过定义类 AsyncSocket 封装原生 Socket 。</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># server.py</span>
<span style="color:#75715e"># Fib microservice</span>

<span style="color:#f92672">from</span> socket <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> fib <span style="color:#f92672">import</span> fib
<span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
<span style="color:#f92672">from</span> select <span style="color:#f92672">import</span> select
<span style="color:#f92672">from</span> concurrent.futures <span style="color:#f92672">import</span> ThreadPoolExecutor <span style="color:#66d9ef">as</span> Pool
<span style="color:#f92672">from</span> concurrent.futures <span style="color:#f92672">import</span> ProcessPoolExecutor <span style="color:#66d9ef">as</span> Pool

pool <span style="color:#f92672">=</span> Pool(<span style="color:#ae81ff">4</span>)

tasks <span style="color:#f92672">=</span> deque()
recv_wait <span style="color:#f92672">=</span> { }   <span style="color:#75715e"># Mapping sockets -&gt; tasks (generators)</span>
send_wait <span style="color:#f92672">=</span> { }
future_wait <span style="color:#f92672">=</span> { }

future_notify, future_event <span style="color:#f92672">=</span> socketpair()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">future_done</span>(future):
    tasks<span style="color:#f92672">.</span>append(future_wait<span style="color:#f92672">.</span>pop(future))
    future_notify<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;x&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">future_monitor</span>():
    <span style="color:#66d9ef">while</span> True:
        <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;recv&#39;</span>, future_event
        future_event<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">100</span>)

tasks<span style="color:#f92672">.</span>append(future_monitor())

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>():
    <span style="color:#66d9ef">while</span> any([tasks, recv_wait, send_wait]):
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> tasks:
            <span style="color:#75715e"># No active tasks to run</span>
            <span style="color:#75715e"># wait for I/O</span>
            can_recv,can_send,_ <span style="color:#f92672">=</span> select(recv_wait,send_wait,[])
            <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> can_recv:
                tasks<span style="color:#f92672">.</span>append(recv_wait<span style="color:#f92672">.</span>pop(s))
            <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> can_send:
                tasks<span style="color:#f92672">.</span>append(send_wait<span style="color:#f92672">.</span>pop(s))


        task <span style="color:#f92672">=</span> tasks<span style="color:#f92672">.</span>popleft()
        <span style="color:#66d9ef">try</span>:
            why, what <span style="color:#f92672">=</span> next(task)   <span style="color:#75715e"># Run to the yield</span>
            <span style="color:#66d9ef">if</span> why <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;recv&#39;</span>:
                <span style="color:#75715e"># Must go wait somewhere</span>
                recv_wait[what] <span style="color:#f92672">=</span> task
            <span style="color:#66d9ef">elif</span> why <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;send&#39;</span>:
                send_wait[what] <span style="color:#f92672">=</span> task
            <span style="color:#66d9ef">elif</span> why <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;future&#39;</span>:
                future_wait[what] <span style="color:#f92672">=</span> task
                what<span style="color:#f92672">.</span>add_done_callback(future_done)

            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(<span style="color:#e6db74">&#34;ARG!&#34;</span>)
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">StopIteration</span>:
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;task done&#34;</span>)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncSocket</span>(object):
    <span style="color:#66d9ef">def</span> __init__(self, sock):
        self<span style="color:#f92672">.</span>sock <span style="color:#f92672">=</span> sock
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recv</span>(self, maxsize):
        <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;recv&#39;</span>, self<span style="color:#f92672">.</span>sock
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>sock<span style="color:#f92672">.</span>recv(maxsize)
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">send</span>(self, data):
        <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;send&#39;</span>, self<span style="color:#f92672">.</span>sock
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>sock<span style="color:#f92672">.</span>send(data)
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">accept</span>(self):
        <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;recv&#39;</span>, self<span style="color:#f92672">.</span>sock
        client, addr <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sock<span style="color:#f92672">.</span>accept()
        <span style="color:#66d9ef">return</span> AsyncSocket(client), addr
    <span style="color:#66d9ef">def</span> __getattr__(self, name):
        <span style="color:#66d9ef">return</span> getattr(self<span style="color:#f92672">.</span>sock, name)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib_server</span>(address):
    sock <span style="color:#f92672">=</span> AsyncSocket(socket(AF_INET, SOCK_STREAM))
    sock<span style="color:#f92672">.</span>setsockopt(SOL_SOCKET, SO_REUSEADDR, <span style="color:#ae81ff">1</span>)
    sock<span style="color:#f92672">.</span>bind(address)
    sock<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">5</span>)
    <span style="color:#66d9ef">while</span> True:
        client, addr <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> sock.accept()  <span style="color:#75715e"># blocking</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Connection&#34;</span>, addr)
        tasks<span style="color:#f92672">.</span>append(fib_handler(client))

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib_handler</span>(client):
    <span style="color:#66d9ef">while</span> True:
        req <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> client.recv(<span style="color:#ae81ff">100</span>)   <span style="color:#75715e"># blocking</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> req:
            <span style="color:#66d9ef">break</span>
        n <span style="color:#f92672">=</span> int(req)
        future <span style="color:#f92672">=</span> pool<span style="color:#f92672">.</span>submit(fib, n)
        <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;future&#39;</span>, future
        result <span style="color:#f92672">=</span> future<span style="color:#f92672">.</span>result()    <span style="color:#75715e">#  Blocks</span>
        resp <span style="color:#f92672">=</span> str(result)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;ascii&#39;</span>) <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>
        <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> client.send(resp)    <span style="color:#75715e"># blocking</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Closed&#34;</span>)

tasks<span style="color:#f92672">.</span>append(fib_server((<span style="color:#e6db74">&#39;&#39;</span>,<span style="color:#ae81ff">25000</span>)))
run()</code></pre></div>

<p>TODO1: pydocs <a href="https://docs.python.org/3/library/asyncio.html">asyncio Asynchronous I/O, event loop, coroutines and tasks</a><br />
TODO2: <a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a></p>

<p>参考文档</p>

<blockquote>
<ul>
<li>Python 3 docs <a href="https://docs.python.org/3/library/concurrent.futures.html">Launching parallel tasks</a></li>
<li>Masnun (2016-03-29）<a href="http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html">Python: a quick intro to the concurrent.futures  module</a></li>
<li>Unix 域套接字 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a></li>
<li>Beej&rsquo;s Guide to Unix IPC (2015-12-01) <a href="http://beej.us/guide/bgipc/output/html/multipage/unixsock.html">Chapter 11 Unix Sockets</a></li>
<li>Troy D. Hanson (2015-02-16) <a href="http://troydhanson.github.io/network/Unix_domain_sockets.html">UNIX domain sockets</a></li>
</ul>
</blockquote>

<p>封面图片来自 <a href="https://dribbble.com/shots/2843135-Seated-Superman">Seated Superman</a> <a href="https://dribbble.com/3rdfloor"><i class="fa fa-dribbble" aria-hidden="true"></i> Warren Willmott</a></p>
         <div id="disqus_thread">
  <a href="#" onclick="disqus();return false;"> 点击启用 Disqus 评论文章 <i class="fa fa-comments" aria-hidden="true"></i></a>
</div>

<script type="text/javascript">
var disqus_loaded = false;
function disqus() {
  if (!disqus_loaded) {
    
    
    
    

    disqus_loaded = true;
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'wushuzh';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }
};
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </div>
    </div>
  </div>
</div>
<noscript>
  <style>.jsonly { display: none }</style>
</noscript>

          </div>
      </div>
  </div>
  <script src="https://wushuzh.github.io/js/jquery.min.js"></script>
<script src="https://wushuzh.github.io/js/bootstrap.min.js"></script>
<script src="https://wushuzh.github.io/js/jquery.cookie.js"> </script>
<script src="https://wushuzh.github.io/js/ekko-lightbox.js"></script>
<script src="https://wushuzh.github.io/js/jquery.scrollTo.min.js"></script>
<script src="https://wushuzh.github.io/js/masonry.pkgd.min.js"></script>
<script src="https://wushuzh.github.io/js/imagesloaded.pkgd.min.js"></script>
<script src="https://wushuzh.github.io/js/owl.carousel.min.js"></script>
<script src="https://wushuzh.github.io/js/front.js"></script>

<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</body>
</html>
